{"files_processed":{"questions.txt":{"filename":"test-questions.txt","content_preview":"The Indian high court judgement dataset contains judgements from the Indian High Courts, downloaded from [ecourts website](https://judgments.ecourts.gov.in/). It contains judgments of 25 high courts, "}},"response":"```python\nimport pandas as pd\nimport numpy as np\nimport pyarrow.dataset as ds\nimport s3fs\nfrom scipy.stats import linregress\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport base64\nfrom io import BytesIO\nimport json\n\n# Configure S3 file system for anonymous access\ns3 = s3fs.S3FileSystem(anon=True)\n\n# Base path for the dataset\nbase_s3_path = \"s3://indian-high-court-judgments/metadata/parquet/\"\n\n# Initialize variables for results\nmost_cases_court = None\nregression_slope = None\nplot_base64 = None\n\ntry:\n    # Create a PyArrow dataset object for efficient S3 access and filtering\n    dataset = ds.dataset(base_s3_path, format=\"parquet\", filesystem=s3)\n\n    # --- Question 1: Which high court disposed the most cases from 2019 - 2022? ---\n\n    # Define filters for years 2019-2022 using the 'year' partition column\n    filter_q1 = (ds.field(\"year\") >= 2019) & (ds.field(\"year\") <= 2022)\n\n    # Select only the 'court' column to minimize data transfer\n    columns_q1 = [\"court\"]\n\n    # Read the filtered data into a pandas DataFrame\n    table_q1 = dataset.to_table(filter=filter_q1, columns=columns_q1)\n    df_q1 = table_q1.to_pandas()\n\n    # Count cases per court\n    if not df_q1.empty:\n        court_counts = df_q1['court'].value_counts()\n        # Get the court with the most cases\n        most_cases_court = court_counts.index[0]\n    else:\n        most_cases_court = \"No data found for years 2019-2022.\"\n\n    # --- Question 2 & 3: Regression slope and plot for court=33_10 ---\n\n    # Define the filter for court '33_10' (as per sample data and question)\n    filter_q2_q3 = ds.field(\"court\") == \"33_10\"\n\n    # Select relevant columns for delay calculation and regression\n    columns_q2_q3 = [\"date_of_registration\", \"decision_date\", \"year\"]\n\n    # Read the data for the specific court\n    table_q2_q3 = dataset.to_table(filter=filter_q2_q3, columns=columns_q2_q3)\n    df_q2_q3 = table_q2_q3.to_pandas()\n\n    # Convert date columns to datetime objects\n    # 'date_of_registration' format is 'DD-MM-YYYY'\n    df_q2_q3['date_of_registration'] = pd.to_datetime(df_q2_q3['date_of_registration'], format='%d-%m-%Y', errors='coerce')\n    # 'decision_date' is already DATE type, but ensure pandas recognizes it as datetime\n    df_q2_q3['decision_date'] = pd.to_datetime(df_q2_q3['decision_date'], errors='coerce')\n\n    # Calculate delay in days\n    df_q2_q3['delay_days'] = (df_q2_q3['decision_date'] - df_q2_q3['date_of_registration']).dt.days\n\n    # Drop rows where delay_days or year is NaN/NaT, as these cannot be used for regression\n    df_q2_cleaned = df_q2_q3.dropna(subset=['year', 'delay_days'])\n\n    # Ensure 'year' is numeric (it's BIGINT, so should be fine, but good practice)\n    df_q2_cleaned['year'] = pd.to_numeric(df_q2_cleaned['year'], errors='coerce')\n    df_q2_cleaned = df_q2_cleaned.dropna(subset=['year']) # Drop if year became NaN after conversion\n\n    # --- Question 2: Perform linear regression ---\n    # Need at least 2 unique x values (years) for regression\n    if not df_q2_cleaned.empty and len(df_q2_cleaned['year'].unique()) > 1:\n        slope, intercept, r_value, p_value, std_err = linregress(df_q2_cleaned['year'], df_q2_cleaned['delay_days'])\n        regression_slope = slope\n    else:\n        regression_slope = \"Not enough data for regression or only one unique year for court 33_10.\"\n\n    # --- Question 3: Generate plot ---\n    if not df_q2_cleaned.empty:\n        plt.figure(figsize=(10, 6))\n        # Use seaborn.regplot to automatically draw scatter plot and regression line\n        sns.regplot(x='year', y='delay_days', data=df_q2_cleaned,\n                    scatter_kws={'alpha':0.3, 's':10}, # s for marker size\n                    line_kws={'color':'red', 'lw':2}) # lw for line width\n        plt.title('Delay in Judgment Decision by Year for Court 33_10')\n        plt.xlabel('Year')\n        plt.ylabel('Days of Delay (Decision Date - Registration Date)')\n        plt.grid(True, linestyle='--', alpha=0.7)\n        plt.tight_layout()\n\n        # Save plot to a BytesIO object in webp format for efficiency\n        buffer = BytesIO()\n        plt.savefig(buffer, format='webp', dpi=100) # dpi can be adjusted if size is an issue\n        buffer.seek(0)\n        plot_base64 = \"data:image/webp;base64,\" + base64.b64encode(buffer.getvalue()).decode('utf-8')\n        plt.close() # Close the plot to free memory\n\n    else:\n        plot_base64 = \"No data available to generate plot for court 33_10.\"\n\nexcept Exception as e:\n    # General error handling for any stage of the process\n    most_cases_court = f\"Error processing Q1: {e}\"\n    regression_slope = f\"Error processing Q2: {e}\"\n    plot_base64 = f\"Error generating plot for Q3: {e}\"\n\n# Prepare the final JSON output\nresult = {\n    \"Which high court disposed the most cases from 2019 - 2022?\": most_cases_court,\n    \"What's the regression slope of the date_of_registration - decision_date by year in the court=33_10?\": regression_slope,\n    \"Plot the year and # of days of delay from the above question as a scatterplot with a regression line. Encode as a base64 data URI under 100,000 characters\": plot_base64\n}\n\nprint(json.dumps(result, indent=2))\n```"}